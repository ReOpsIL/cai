- Add configuration file (if not exists) named ~/cai.conf, when cai app loads it should read all settings from ~/cai.conf configuration file.
- Configuration file should include all sorts of attributes and settings that ALL cai code will use. Do NOT save openrouter API key in configuration file or other user secret information.
- Add command @set-model [*gemini*free*] - cai will list available models in openrouter. The command will receive an optional model name wild card and list only models that match wild card. The command will add a model number before each model and the user will be able to choose a model from the list, cai will wait for input from the user. The input should be a model number only. If the user will press escape or the input will be empty (pressing enter without number/value) then no model will be selected.
if the user will provide a model index (from the list) cai will use the selected model (eg by using model name from teh list) and save the selected model name for future use in ~/cai.conf configuration file. Do not earse ~/cai.conf - just update relevant attribute and save.
- Genrate a documents in docs/cai.md with description of current features and functionality implemented in source code


- split main.rs into modules
  * History module - for handling prompt history - saveing, loading, listing, searching
  * Configuration module - for handling configuration loading and saving
  * Command handle - for hanlding commands.
  * Commands modules - each @[command] should have its own module for source code clarity

Here’s a rephrased and clearer version of your task list:

---
Here’s a rephrased version of your prompt and feature list for clarity and better structure:

---

**Add a new module called `files` to support file-related operations with the following commands:**

* `@list-files [wildcard]`: Recursively lists all files that match the provided wildcard pattern.
* `@list-folders [wildcard]`: Recursively lists all folders that match the provided wildcard pattern.
* `@read-file [memory-id] [filename]`: Reads a single file and stores its content in the chat module’s memory hashmap under the key `memory-id`.
* `@read-files [memory-id] [wildcard]`: Reads all files matching the wildcard pattern and stores them in the memory hashmap under the key `memory-id`.
* `@read-folder [memory-id] [wildcard]`: Reads all files from folders that match the wildcard and stores them in the memory hashmap under `memory-id`.

---

**Enhance the `chat` module with the following capabilities:**

* `@reset-context`: Clears the memory hashmap entirely, effectively resetting the chat context.
* `@save-context [file-name]`: Saves the current contents of the memory hashmap to the specified file.

---

**Enable in-chat command parsing and dynamic prompt enrichment:**

* Implement a mechanism in the chat module to detect and process embedded commands (e.g., any input starting with `@`).
* When a user includes commands in their prompt (e.g., `Hey I want you to @read-files my-features feature_a*.md and extend each feature`), the system should:

  * Execute the detected command(s).
  * Inject the resulting content into the prompt in the appropriate location.
  * Format injected content using code blocks as follows:

    ```
    [memory-id]:  
    [loaded content]  
    ```

---

This design allows users to create more dynamic, content-rich prompts that integrate file-based inputs seamlessly. Would you like help turning this into a structured implementation plan or code?




