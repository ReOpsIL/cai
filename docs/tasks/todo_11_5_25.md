
**Add command registry**
- Create a module named commands_registry, the module will hold a map of all commands.
- each command will have a regex pattern accorrding to command structure that will allow to indentify command in a prompt (eg. `@list-files [wildcard]`) extract command parameters(eg. ` in the  save-file command the parameters are file-name and file-content: @save-file [file-name] [file-content]` )
- When that user recieves a prompt - that chat loop will parse the prompt and use command registry mocule to identify commands in the prompt. once command is identified using all commands regex in commands registry  - the command registry module will Execute the command and pass the values to command implemntation. The parameters will be extracted using regex.


* `@list-files [wildcard]`: Recursively lists all files that match the provided wildcard pattern.
* `@list-folders [wildcard]`: Recursively lists all folders that match the provided wildcard pattern.
* `@read-file [memory-id] [filename]`: Reads a single file and stores its content in the chat moduleâ€™s memory hashmap under the key `memory-id`.
* `@read-files [memory-id] [wildcard]`: Reads all files matching the wildcard pattern and stores them in the memory hashmap under the key `memory-id`.
* `@read-folder [memory-id] [wildcard]`: Reads all files from folders that match the wildcard and stores them in the memory hashmap under `memory-id`.

---

**Enhance the `chat` module with the following capabilities:**

* `@reset-context`: Clears the memory hashmap entirely, effectively resetting the chat context.
* `@save-context [file-name]`: Saves the current contents of the memory hashmap to the specified file.

---

**Enable in-chat command parsing and dynamic prompt enrichment:**

* Implement a mechanism in the chat module to detect and process embedded commands (e.g., any input starting with `@`).
* When a user includes commands in their prompt (e.g., `Hey I want you to @read-files my-features feature_a*.md and extend each feature`), the system should:

  * Execute the detected command(s).
  * Inject the resulting content into the prompt in the appropriate location.
  * Format injected content using code blocks as follows:

    ```
    [memory-id]:
    [loaded content]
    ```

---

This design allows users to create more dynamic, content-rich prompts that integrate file-based inputs seamlessly. Would you like help turning this into a structured implementation plan or code?
